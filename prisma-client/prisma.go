// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Cart(params CartWhereUniqueInput) *CartExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CartWhereUniqueInput!", "Cart"},
		"cart",
		[]string{"id"})

	return &CartExec{ret}
}

type CartsParams struct {
	Where   *CartWhereInput   `json:"where,omitempty"`
	OrderBy *CartOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Carts(params *CartsParams) *CartExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CartWhereInput", "CartOrderByInput", "Cart"},
		"carts",
		[]string{"id"})

	return &CartExecArray{ret}
}

type CartsConnectionParams struct {
	Where   *CartWhereInput   `json:"where,omitempty"`
	OrderBy *CartOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) CartsConnection(params *CartsConnectionParams) *CartConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CartWhereInput", "CartOrderByInput", "Cart"},
		"cartsConnection",
		[]string{"edges", "pageInfo"})

	return &CartConnectionExec{ret}
}

func (client *Client) Product(params ProductWhereUniqueInput) *ProductExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProductWhereUniqueInput!", "Product"},
		"product",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

type ProductsParams struct {
	Where   *ProductWhereInput   `json:"where,omitempty"`
	OrderBy *ProductOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Products(params *ProductsParams) *ProductExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "Product"},
		"products",
		[]string{"id", "available", "price", "count"})

	return &ProductExecArray{ret}
}

type ProductsConnectionParams struct {
	Where   *ProductWhereInput   `json:"where,omitempty"`
	OrderBy *ProductOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) ProductsConnection(params *ProductsConnectionParams) *ProductConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "Product"},
		"productsConnection",
		[]string{"edges", "pageInfo"})

	return &ProductConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "name", "email"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateCart(params CartCreateInput) *CartExec {
	ret := client.Client.Create(
		params,
		[2]string{"CartCreateInput!", "Cart"},
		"createCart",
		[]string{"id"})

	return &CartExec{ret}
}

type CartUpdateParams struct {
	Data  CartUpdateInput      `json:"data"`
	Where CartWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCart(params CartUpdateParams) *CartExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CartUpdateInput!", "CartWhereUniqueInput!", "Cart"},
		"updateCart",
		[]string{"id"})

	return &CartExec{ret}
}

type CartUpsertParams struct {
	Where  CartWhereUniqueInput `json:"where"`
	Create CartCreateInput      `json:"create"`
	Update CartUpdateInput      `json:"update"`
}

func (client *Client) UpsertCart(params CartUpsertParams) *CartExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CartWhereUniqueInput!", "CartCreateInput!", "CartUpdateInput!", "Cart"},
		"upsertCart",
		[]string{"id"})

	return &CartExec{ret}
}

func (client *Client) DeleteCart(params CartWhereUniqueInput) *CartExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CartWhereUniqueInput!", "Cart"},
		"deleteCart",
		[]string{"id"})

	return &CartExec{ret}
}

func (client *Client) DeleteManyCarts(params *CartWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CartWhereInput", "deleteManyCarts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProduct(params ProductCreateInput) *ProductExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProductCreateInput!", "Product"},
		"createProduct",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

type ProductUpdateParams struct {
	Data  ProductUpdateInput      `json:"data"`
	Where ProductWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProduct(params ProductUpdateParams) *ProductExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProductUpdateInput!", "ProductWhereUniqueInput!", "Product"},
		"updateProduct",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

type ProductUpdateManyParams struct {
	Data  ProductUpdateManyMutationInput `json:"data"`
	Where *ProductWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProducts(params ProductUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProductUpdateManyMutationInput!", "ProductWhereInput"},
		"updateManyProducts")
	return &BatchPayloadExec{exec}
}

type ProductUpsertParams struct {
	Where  ProductWhereUniqueInput `json:"where"`
	Create ProductCreateInput      `json:"create"`
	Update ProductUpdateInput      `json:"update"`
}

func (client *Client) UpsertProduct(params ProductUpsertParams) *ProductExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProductWhereUniqueInput!", "ProductCreateInput!", "ProductUpdateInput!", "Product"},
		"upsertProduct",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

func (client *Client) DeleteProduct(params ProductWhereUniqueInput) *ProductExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProductWhereUniqueInput!", "Product"},
		"deleteProduct",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

func (client *Client) DeleteManyProducts(params *ProductWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProductWhereInput", "deleteManyProducts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type ProductOrderByInput string

const (
	ProductOrderByInputIDAsc         ProductOrderByInput = "id_ASC"
	ProductOrderByInputIDDesc        ProductOrderByInput = "id_DESC"
	ProductOrderByInputAvailableAsc  ProductOrderByInput = "available_ASC"
	ProductOrderByInputAvailableDesc ProductOrderByInput = "available_DESC"
	ProductOrderByInputPriceAsc      ProductOrderByInput = "price_ASC"
	ProductOrderByInputPriceDesc     ProductOrderByInput = "price_DESC"
	ProductOrderByInputCountAsc      ProductOrderByInput = "count_ASC"
	ProductOrderByInputCountDesc     ProductOrderByInput = "count_DESC"
)

type CartOrderByInput string

const (
	CartOrderByInputIDAsc  CartOrderByInput = "id_ASC"
	CartOrderByInputIDDesc CartOrderByInput = "id_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc     UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc    UserOrderByInput = "id_DESC"
	UserOrderByInputNameAsc   UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc  UserOrderByInput = "name_DESC"
	UserOrderByInputEmailAsc  UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc UserOrderByInput = "email_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type CartWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ProductWhereInput struct {
	ID                 *string             `json:"id,omitempty"`
	IDNot              *string             `json:"id_not,omitempty"`
	IDIn               []string            `json:"id_in,omitempty"`
	IDNotIn            []string            `json:"id_not_in,omitempty"`
	IDLt               *string             `json:"id_lt,omitempty"`
	IDLte              *string             `json:"id_lte,omitempty"`
	IDGt               *string             `json:"id_gt,omitempty"`
	IDGte              *string             `json:"id_gte,omitempty"`
	IDContains         *string             `json:"id_contains,omitempty"`
	IDNotContains      *string             `json:"id_not_contains,omitempty"`
	IDStartsWith       *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string             `json:"id_not_ends_with,omitempty"`
	Available          *bool               `json:"available,omitempty"`
	AvailableNot       *bool               `json:"available_not,omitempty"`
	Price              *string             `json:"price,omitempty"`
	PriceNot           *string             `json:"price_not,omitempty"`
	PriceIn            []string            `json:"price_in,omitempty"`
	PriceNotIn         []string            `json:"price_not_in,omitempty"`
	PriceLt            *string             `json:"price_lt,omitempty"`
	PriceLte           *string             `json:"price_lte,omitempty"`
	PriceGt            *string             `json:"price_gt,omitempty"`
	PriceGte           *string             `json:"price_gte,omitempty"`
	PriceContains      *string             `json:"price_contains,omitempty"`
	PriceNotContains   *string             `json:"price_not_contains,omitempty"`
	PriceStartsWith    *string             `json:"price_starts_with,omitempty"`
	PriceNotStartsWith *string             `json:"price_not_starts_with,omitempty"`
	PriceEndsWith      *string             `json:"price_ends_with,omitempty"`
	PriceNotEndsWith   *string             `json:"price_not_ends_with,omitempty"`
	Count              *int32              `json:"count,omitempty"`
	CountNot           *int32              `json:"count_not,omitempty"`
	CountIn            []int32             `json:"count_in,omitempty"`
	CountNotIn         []int32             `json:"count_not_in,omitempty"`
	CountLt            *int32              `json:"count_lt,omitempty"`
	CountLte           *int32              `json:"count_lte,omitempty"`
	CountGt            *int32              `json:"count_gt,omitempty"`
	CountGte           *int32              `json:"count_gte,omitempty"`
	And                []ProductWhereInput `json:"AND,omitempty"`
}

type CartWhereInput struct {
	ID              *string            `json:"id,omitempty"`
	IDNot           *string            `json:"id_not,omitempty"`
	IDIn            []string           `json:"id_in,omitempty"`
	IDNotIn         []string           `json:"id_not_in,omitempty"`
	IDLt            *string            `json:"id_lt,omitempty"`
	IDLte           *string            `json:"id_lte,omitempty"`
	IDGt            *string            `json:"id_gt,omitempty"`
	IDGte           *string            `json:"id_gte,omitempty"`
	IDContains      *string            `json:"id_contains,omitempty"`
	IDNotContains   *string            `json:"id_not_contains,omitempty"`
	IDStartsWith    *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string            `json:"id_not_ends_with,omitempty"`
	CatalogSome     *ProductWhereInput `json:"catalog_some,omitempty"`
	And             []CartWhereInput   `json:"AND,omitempty"`
}

type ProductWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserWhereInput struct {
	ID                 *string          `json:"id,omitempty"`
	IDNot              *string          `json:"id_not,omitempty"`
	IDIn               []string         `json:"id_in,omitempty"`
	IDNotIn            []string         `json:"id_not_in,omitempty"`
	IDLt               *string          `json:"id_lt,omitempty"`
	IDLte              *string          `json:"id_lte,omitempty"`
	IDGt               *string          `json:"id_gt,omitempty"`
	IDGte              *string          `json:"id_gte,omitempty"`
	IDContains         *string          `json:"id_contains,omitempty"`
	IDNotContains      *string          `json:"id_not_contains,omitempty"`
	IDStartsWith       *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string          `json:"id_not_ends_with,omitempty"`
	Name               *string          `json:"name,omitempty"`
	NameNot            *string          `json:"name_not,omitempty"`
	NameIn             []string         `json:"name_in,omitempty"`
	NameNotIn          []string         `json:"name_not_in,omitempty"`
	NameLt             *string          `json:"name_lt,omitempty"`
	NameLte            *string          `json:"name_lte,omitempty"`
	NameGt             *string          `json:"name_gt,omitempty"`
	NameGte            *string          `json:"name_gte,omitempty"`
	NameContains       *string          `json:"name_contains,omitempty"`
	NameNotContains    *string          `json:"name_not_contains,omitempty"`
	NameStartsWith     *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string          `json:"name_not_ends_with,omitempty"`
	Email              *string          `json:"email,omitempty"`
	EmailNot           *string          `json:"email_not,omitempty"`
	EmailIn            []string         `json:"email_in,omitempty"`
	EmailNotIn         []string         `json:"email_not_in,omitempty"`
	EmailLt            *string          `json:"email_lt,omitempty"`
	EmailLte           *string          `json:"email_lte,omitempty"`
	EmailGt            *string          `json:"email_gt,omitempty"`
	EmailGte           *string          `json:"email_gte,omitempty"`
	EmailContains      *string          `json:"email_contains,omitempty"`
	EmailNotContains   *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith    *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith      *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith   *string          `json:"email_not_ends_with,omitempty"`
	CartSome           *CartWhereInput  `json:"cart_some,omitempty"`
	And                []UserWhereInput `json:"AND,omitempty"`
}

type CartCreateInput struct {
	ID      *string                 `json:"id,omitempty"`
	Catalog *ProductCreateManyInput `json:"catalog,omitempty"`
}

type ProductCreateManyInput struct {
	Create  []ProductCreateInput      `json:"create,omitempty"`
	Connect []ProductWhereUniqueInput `json:"connect,omitempty"`
}

type ProductCreateInput struct {
	ID        *string `json:"id,omitempty"`
	Available bool    `json:"available"`
	Price     string  `json:"price"`
	Count     int32   `json:"count"`
}

type CartUpdateInput struct {
	Catalog *ProductUpdateManyInput `json:"catalog,omitempty"`
}

type ProductUpdateManyInput struct {
	Create     []ProductCreateInput                      `json:"create,omitempty"`
	Update     []ProductUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []ProductUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []ProductWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []ProductWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []ProductWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []ProductWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []ProductScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []ProductUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type ProductUpdateWithWhereUniqueNestedInput struct {
	Where ProductWhereUniqueInput `json:"where"`
	Data  ProductUpdateDataInput  `json:"data"`
}

type ProductUpdateDataInput struct {
	Available *bool   `json:"available,omitempty"`
	Price     *string `json:"price,omitempty"`
	Count     *int32  `json:"count,omitempty"`
}

type ProductUpsertWithWhereUniqueNestedInput struct {
	Where  ProductWhereUniqueInput `json:"where"`
	Update ProductUpdateDataInput  `json:"update"`
	Create ProductCreateInput      `json:"create"`
}

type ProductScalarWhereInput struct {
	ID                 *string                   `json:"id,omitempty"`
	IDNot              *string                   `json:"id_not,omitempty"`
	IDIn               []string                  `json:"id_in,omitempty"`
	IDNotIn            []string                  `json:"id_not_in,omitempty"`
	IDLt               *string                   `json:"id_lt,omitempty"`
	IDLte              *string                   `json:"id_lte,omitempty"`
	IDGt               *string                   `json:"id_gt,omitempty"`
	IDGte              *string                   `json:"id_gte,omitempty"`
	IDContains         *string                   `json:"id_contains,omitempty"`
	IDNotContains      *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                   `json:"id_not_ends_with,omitempty"`
	Available          *bool                     `json:"available,omitempty"`
	AvailableNot       *bool                     `json:"available_not,omitempty"`
	Price              *string                   `json:"price,omitempty"`
	PriceNot           *string                   `json:"price_not,omitempty"`
	PriceIn            []string                  `json:"price_in,omitempty"`
	PriceNotIn         []string                  `json:"price_not_in,omitempty"`
	PriceLt            *string                   `json:"price_lt,omitempty"`
	PriceLte           *string                   `json:"price_lte,omitempty"`
	PriceGt            *string                   `json:"price_gt,omitempty"`
	PriceGte           *string                   `json:"price_gte,omitempty"`
	PriceContains      *string                   `json:"price_contains,omitempty"`
	PriceNotContains   *string                   `json:"price_not_contains,omitempty"`
	PriceStartsWith    *string                   `json:"price_starts_with,omitempty"`
	PriceNotStartsWith *string                   `json:"price_not_starts_with,omitempty"`
	PriceEndsWith      *string                   `json:"price_ends_with,omitempty"`
	PriceNotEndsWith   *string                   `json:"price_not_ends_with,omitempty"`
	Count              *int32                    `json:"count,omitempty"`
	CountNot           *int32                    `json:"count_not,omitempty"`
	CountIn            []int32                   `json:"count_in,omitempty"`
	CountNotIn         []int32                   `json:"count_not_in,omitempty"`
	CountLt            *int32                    `json:"count_lt,omitempty"`
	CountLte           *int32                    `json:"count_lte,omitempty"`
	CountGt            *int32                    `json:"count_gt,omitempty"`
	CountGte           *int32                    `json:"count_gte,omitempty"`
	And                []ProductScalarWhereInput `json:"AND,omitempty"`
	Or                 []ProductScalarWhereInput `json:"OR,omitempty"`
	Not                []ProductScalarWhereInput `json:"NOT,omitempty"`
}

type ProductUpdateManyWithWhereNestedInput struct {
	Where ProductScalarWhereInput    `json:"where"`
	Data  ProductUpdateManyDataInput `json:"data"`
}

type ProductUpdateManyDataInput struct {
	Available *bool   `json:"available,omitempty"`
	Price     *string `json:"price,omitempty"`
	Count     *int32  `json:"count,omitempty"`
}

type ProductUpdateInput struct {
	Available *bool   `json:"available,omitempty"`
	Price     *string `json:"price,omitempty"`
	Count     *int32  `json:"count,omitempty"`
}

type ProductUpdateManyMutationInput struct {
	Available *bool   `json:"available,omitempty"`
	Price     *string `json:"price,omitempty"`
	Count     *int32  `json:"count,omitempty"`
}

type UserCreateInput struct {
	ID    *string              `json:"id,omitempty"`
	Name  string               `json:"name"`
	Email string               `json:"email"`
	Cart  *CartCreateManyInput `json:"cart,omitempty"`
}

type CartCreateManyInput struct {
	Create  []CartCreateInput      `json:"create,omitempty"`
	Connect []CartWhereUniqueInput `json:"connect,omitempty"`
}

type UserUpdateInput struct {
	Name  *string              `json:"name,omitempty"`
	Email *string              `json:"email,omitempty"`
	Cart  *CartUpdateManyInput `json:"cart,omitempty"`
}

type CartUpdateManyInput struct {
	Create     []CartCreateInput                      `json:"create,omitempty"`
	Update     []CartUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []CartUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []CartWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []CartWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []CartWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []CartWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []CartScalarWhereInput                 `json:"deleteMany,omitempty"`
}

type CartUpdateWithWhereUniqueNestedInput struct {
	Where CartWhereUniqueInput `json:"where"`
	Data  CartUpdateDataInput  `json:"data"`
}

type CartUpdateDataInput struct {
	Catalog *ProductUpdateManyInput `json:"catalog,omitempty"`
}

type CartUpsertWithWhereUniqueNestedInput struct {
	Where  CartWhereUniqueInput `json:"where"`
	Update CartUpdateDataInput  `json:"update"`
	Create CartCreateInput      `json:"create"`
}

type CartScalarWhereInput struct {
	ID              *string                `json:"id,omitempty"`
	IDNot           *string                `json:"id_not,omitempty"`
	IDIn            []string               `json:"id_in,omitempty"`
	IDNotIn         []string               `json:"id_not_in,omitempty"`
	IDLt            *string                `json:"id_lt,omitempty"`
	IDLte           *string                `json:"id_lte,omitempty"`
	IDGt            *string                `json:"id_gt,omitempty"`
	IDGte           *string                `json:"id_gte,omitempty"`
	IDContains      *string                `json:"id_contains,omitempty"`
	IDNotContains   *string                `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                `json:"id_not_ends_with,omitempty"`
	And             []CartScalarWhereInput `json:"AND,omitempty"`
	Or              []CartScalarWhereInput `json:"OR,omitempty"`
	Not             []CartScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Name  *string `json:"name,omitempty"`
	Email *string `json:"email,omitempty"`
}

type CartSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *CartWhereInput              `json:"node,omitempty"`
	And                        []CartSubscriptionWhereInput `json:"AND,omitempty"`
}

type ProductSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProductWhereInput              `json:"node,omitempty"`
	And                        []ProductSubscriptionWhereInput `json:"AND,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
}

type CartExec struct {
	exec *prisma.Exec
}

type CatalogParamsExec struct {
	Where   *ProductWhereInput
	OrderBy *ProductOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CartExec) Catalog(params *CatalogParamsExec) *ProductExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "Product"},
		"catalog",
		[]string{"id", "available", "price", "count"})

	return &ProductExecArray{ret}
}

func (instance CartExec) Exec(ctx context.Context) (*Cart, error) {
	var v Cart
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CartExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CartExecArray struct {
	exec *prisma.Exec
}

func (instance CartExecArray) Exec(ctx context.Context) ([]Cart, error) {
	var v []Cart
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Cart struct {
	ID string `json:"id"`
}

type ProductExec struct {
	exec *prisma.Exec
}

func (instance ProductExec) Exec(ctx context.Context) (*Product, error) {
	var v Product
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductExecArray struct {
	exec *prisma.Exec
}

func (instance ProductExecArray) Exec(ctx context.Context) ([]Product, error) {
	var v []Product
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Product struct {
	ID        string `json:"id"`
	Available bool   `json:"available"`
	Price     string `json:"price"`
	Count     int32  `json:"count"`
}

type CartConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CartConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CartConnectionExec) Edges() *CartEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CartWhereInput", "CartOrderByInput", "CartEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Cart"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CartEdgeExecArray{nodes}
}

func (instance *CartConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCart"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CartConnectionExec) Exec(ctx context.Context) (*CartConnection, error) {
	var v CartConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CartConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CartConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CartConnectionExecArray) Exec(ctx context.Context) ([]CartConnection, error) {
	var v []CartConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CartConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []CartEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type CartEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CartEdgeExec) Node() *CartExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Cart"},
		"node",
		[]string{"id"})

	return &CartExec{ret}
}

func (instance CartEdgeExec) Exec(ctx context.Context) (*CartEdge, error) {
	var v CartEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CartEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CartEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CartEdgeExecArray) Exec(ctx context.Context) ([]CartEdge, error) {
	var v []CartEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CartEdge struct {
	Node   Cart   `json:"node"`
	Cursor string `json:"cursor"`
}

type ProductConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProductConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProductConnectionExec) Edges() *ProductEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "ProductEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Product"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &ProductEdgeExecArray{nodes}
}

func (instance *ProductConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProduct"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProductConnectionExec) Exec(ctx context.Context) (*ProductConnection, error) {
	var v ProductConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProductConnectionExecArray) Exec(ctx context.Context) ([]ProductConnection, error) {
	var v []ProductConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []ProductEdge `json:"edges"`
}

type ProductEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProductEdgeExec) Node() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"node",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

func (instance ProductEdgeExec) Exec(ctx context.Context) (*ProductEdge, error) {
	var v ProductEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEdgeExecArray) Exec(ctx context.Context) ([]ProductEdge, error) {
	var v []ProductEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductEdge struct {
	Node   Product `json:"node"`
	Cursor string  `json:"cursor"`
}

type UserExec struct {
	exec *prisma.Exec
}

type CartParamsExec struct {
	Where   *CartWhereInput
	OrderBy *CartOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Cart(params *CartParamsExec) *CartExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CartWhereInput", "CartOrderByInput", "Cart"},
		"cart",
		[]string{"id"})

	return &CartExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type CartSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CartSubscriptionPayloadExec) Node() *CartExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Cart"},
		"node",
		[]string{"id"})

	return &CartExec{ret}
}

func (instance *CartSubscriptionPayloadExec) PreviousValues() *CartPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CartPreviousValues"},
		"previousValues",
		[]string{"id"})

	return &CartPreviousValuesExec{ret}
}

func (instance CartSubscriptionPayloadExec) Exec(ctx context.Context) (*CartSubscriptionPayload, error) {
	var v CartSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CartSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CartSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CartSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CartSubscriptionPayload, error) {
	var v []CartSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CartSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Cart        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CartPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CartPreviousValuesExec) Exec(ctx context.Context) (*CartPreviousValues, error) {
	var v CartPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CartPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CartPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CartPreviousValuesExecArray) Exec(ctx context.Context) ([]CartPreviousValues, error) {
	var v []CartPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CartPreviousValues struct {
	ID string `json:"id"`
}

type ProductSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProductSubscriptionPayloadExec) Node() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"node",
		[]string{"id", "available", "price", "count"})

	return &ProductExec{ret}
}

func (instance *ProductSubscriptionPayloadExec) PreviousValues() *ProductPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductPreviousValues"},
		"previousValues",
		[]string{"id", "available", "price", "count"})

	return &ProductPreviousValuesExec{ret}
}

func (instance ProductSubscriptionPayloadExec) Exec(ctx context.Context) (*ProductSubscriptionPayload, error) {
	var v ProductSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProductSubscriptionPayload, error) {
	var v []ProductSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Product     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ProductPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProductPreviousValuesExec) Exec(ctx context.Context) (*ProductPreviousValues, error) {
	var v ProductPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProductPreviousValuesExecArray) Exec(ctx context.Context) ([]ProductPreviousValues, error) {
	var v []ProductPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductPreviousValues struct {
	ID        string `json:"id"`
	Available bool   `json:"available"`
	Price     string `json:"price"`
	Count     int32  `json:"count"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name", "email"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "name", "email"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}
